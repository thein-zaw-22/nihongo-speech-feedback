{% extends 'base.html' %}
{% block title %}AI Japanese Feedback{% endblock %}
{% block content %}
<style>
  /* Compact page layout to avoid scrolling */
  .container { padding: 1rem; margin: 0.75rem auto; }
  .section { margin-bottom: 0.75rem; padding: 0.9rem; background: var(--bg-secondary); border-radius: 12px; border: 1px solid var(--border-color); transition: all 0.3s ease; }
  .section:hover { transform: translateY(-1px); box-shadow: var(--shadow-sm); }
  .section h3 { color: var(--text-primary); font-size: 1rem; font-weight: 600; margin-bottom: 0.6rem; display: flex; align-items: center; gap: 0.5rem; }
  .section h3::before { content: ''; width: 3px; height: 16px; background: linear-gradient(135deg, var(--brand), var(--brand-2)); border-radius: 2px; }
  select, textarea { width: 100%; padding: 0.7rem 0.9rem; border: 2px solid var(--border-color); border-radius: 10px; font-size: 0.95rem; transition: all 0.3s ease; background: var(--bg-primary); color: var(--text-primary); }
  select:focus, textarea:focus { outline: none; border-color: var(--brand); box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.15); transform: translateY(-1px); }
  textarea { resize: vertical; min-height: 80px; font-family: inherit; line-height: 1.45; }
  /* Scope button styles to this page to avoid affecting nav */
  .index-page .btn { display: inline-flex; align-items: center; justify-content: center; gap: 0.45rem; padding: 0.65rem 1rem; margin: 0.2rem; border: none; border-radius: 8px; font-size: 0.95rem; font-weight: 600; cursor: pointer; transition: all 0.2s ease; text-decoration: none; min-width: 110px; white-space: nowrap; }
  .index-page .btn-primary { background: linear-gradient(135deg, var(--brand), var(--brand-2)); color: white; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3); }
  .index-page .btn-primary:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(102, 126, 234, 0.35); }
  .index-page .btn-secondary { background: rgba(102, 126, 234, 0.1); color: var(--brand); border: 1px solid rgba(102, 126, 234, 0.2); }
  .index-page .btn-secondary:hover:not(:disabled) { background: rgba(102, 126, 234, 0.18); transform: translateY(-1px); }
  .index-page .btn-danger { background: rgba(239, 68, 68, 0.08); color: #dc2626; border: 1px solid rgba(239, 68, 68, 0.2); }
  .index-page .btn-danger:hover:not(:disabled) { background: rgba(239, 68, 68, 0.16); transform: translateY(-1px); }
  .index-page .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none !important; }
  .index-page .btn-group { display: flex; flex-wrap: wrap; gap: 0.4rem; justify-content: center; margin: 0.5rem 0; }
  /* Toggle button styles */
  .index-page .toggle-group { background: rgba(102,126,234,.08); border: 1px solid rgba(102,126,234,.25); border-radius: 9999px; padding: 4px; gap: .25rem; }
  .index-page .toggle-group .toggle-indicator { position:absolute; top:4px; left:4px; height: calc(100% - 8px); width: calc(50% - 4px); border-radius: 9999px; background: linear-gradient(135deg, var(--brand), var(--brand-2)); box-shadow: 0 4px 14px rgba(102,126,234,.35); transition: transform .25s ease; z-index: 0; }
  .index-page .toggle-group .toggle-btn {
    min-width: 130px;
    padding: .5rem 1rem;
    font-size: .9rem;
    border: none;
    border-radius: 9999px;
    background: transparent;
    color: var(--text-secondary);
    transition: background .2s ease, color .2s ease, transform .15s ease, box-shadow .2s ease;
    position: relative;
    z-index: 1;
  }
  .index-page .toggle-group .toggle-btn:hover { background: rgba(102,126,234,.12); }
  .index-page .toggle-group .toggle-btn:focus-visible { outline: none; box-shadow: 0 0 0 3px rgba(102,126,234,.25); }
  .index-page .toggle-group .toggle-btn.active { color: #fff; transform: translateY(-1px); }
  /* Carousel for input sections */
  .index-page .input-carousel { overflow: hidden; transition: height .28s ease; }
  .index-page .input-track { display: flex; width: 200%; transition: transform .28s ease; will-change: transform; }
  .index-page .input-track .slide { width: 50%; flex: 0 0 50%; opacity: 1; transition: opacity .25s ease; }
  .index-page .input-track .slide.hidden { opacity: 0; pointer-events: none; }
  .dropzone { border: 2px dashed var(--border-color); border-radius: 10px; padding: 1rem; text-align: center; transition: all 0.2s ease; background: var(--bg-secondary); cursor: pointer; }
  .dropzone:hover, .dropzone.highlight { border-color: var(--brand); background: rgba(102, 126, 234, 0.05); transform: translateY(-1px); }
  .dropzone-content { display: flex; flex-direction: column; align-items: center; gap: 0.5rem; }
  .dropzone-icon { font-size: 1.6rem; color: #9ca3af; }
  .dropzone-text { color: var(--text-secondary); font-weight: 500; }
  .dropzone-subtext { color: var(--text-muted); font-size: 0.8rem; }
  /* Attention animation for Download Result */
  @keyframes pulseNotice {
    0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(102,126,234,.0); }
    50% { transform: scale(1.03); box-shadow: 0 0 0 6px rgba(102,126,234,.12); }
    100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(102,126,234,.0); }
  }
  #batchDownload.attention { animation: pulseNotice .9s ease-in-out 4; }
  @media (prefers-reduced-motion: reduce) {
    #batchDownload.attention { animation: none; }
  }
  /* Compact batch dropzone */
  #batchDropzone { padding: .6rem .8rem; }
  #batchDropzone .dropzone-content { gap: .35rem; }
  #batchDropzone .dropzone-icon { font-size: 1.2rem; }
  #batchDropzone .dropzone-text { font-size: .9rem; }
  #batchDropzone .dropzone-subtext { font-size: .75rem; }
  #batchDropzone.has-file { border-color: var(--brand); background: rgba(102,126,234,.08); box-shadow: 0 0 0 3px rgba(102,126,234,.12); }
  #batchDropzone.has-file #batchChosen { color: var(--brand); }
  .audio-player { width: 100%; margin-top: 0.5rem; border-radius: 10px; display: none; background: rgba(102, 126, 234, 0.08); padding: .5rem; border: 1px solid rgba(102, 126, 234, 0.2); }
  .audio-player audio { width: 100%; border-radius: 8px; }
  .audio-controls { display: flex; justify-content: space-between; align-items: center; margin-top: 0.4rem; }
  .audio-info { font-size: 0.875rem; color: var(--text-secondary); }
  .recording-indicator { display: none; align-items: center; gap: 0.5rem; padding: 0.6rem; background: rgba(239, 68, 68, 0.1); border-radius: 10px; border: 1px solid rgba(239, 68, 68, 0.2); margin-top: 0.5rem; }
  .recording-dot { width: 12px; height: 12px; border-radius: 50%; background: #ef4444; animation: pulse 1.5s infinite; }
  @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7);} 70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0);} 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0);} }
  .recording-text { color: #dc2626; font-weight: 600; }
  .submit-section { text-align: center; margin-top: 0.9rem; padding-top: 0.9rem; border-top: 1px solid var(--border-color); }
  .error { background: #fed7d7; color: #c53030; padding: 1rem; border-radius: 12px; margin-bottom: 1.5rem; border-left: 4px solid #e53e3e; }
  .subtitle { text-align: center; color: var(--text-muted); font-size: 0.95rem; margin-bottom: 1rem; line-height: 1.45; }
  @media (max-width: 640px) { .index-page .btn-group { flex-direction: column; } .index-page .btn { width: 100%; } .dropzone { padding: 0.9rem; } }
</style>

<div class="index-page">
<h1 style="text-align: center; font-size: 1.6rem; font-weight: 700; margin-bottom: 0.35rem; background: linear-gradient(135deg, #667eea, #764ba2); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text;">AI Japanese Feedback</h1>
<p class="subtitle">Record audio, upload files, or enter text directly for AI-powered feedback analysis</p>

<!-- Global model selection (applies to both batch and normal) -->
<div class="section">
  <h3>ü§ñ Select AI Model</h3>
  <select id="globalProvider" style="padding:.5rem .7rem; border: 1px solid var(--border-color); border-radius:10px; background: var(--bg-primary); color: var(--text-primary);">
    <option value="openai" {% if selected_provider == 'openai' %}selected{% endif %}>OpenAI (GPT-4o-mini)</option>
    <option value="gemini" {% if selected_provider == 'gemini' %}selected{% endif %}>Google Gemini (2.5-flash-lite)</option>
    <option value="bedrock" {% if selected_provider == 'bedrock' %}selected{% endif %}>AWS Bedrock (Nova Lite)</option>
  </select>
  <div class="dropzone-subtext" style="margin-top:.3rem;">This selection controls both Batch Correction and the normal Audio/Text analysis.</div>
  
</div>

{% if error %}
  <div class="error">{{ error }}</div>
{% endif %}

<div class="section">
  <h3>üìÑ Batch Correction (CSV/Excel)</h3>
  <form id="batchForm" action="{% url 'batch_create' %}" method="post" enctype="multipart/form-data" class="index-page">
    {% csrf_token %}
    <div id="batchDropzone" class="dropzone" onclick="document.getElementById('batchFile').click()" role="button" tabindex="0" aria-label="Upload CSV or Excel">
      <div class="dropzone-content">
        <div class="dropzone-icon">üìë</div>
        <div class="dropzone-text">Upload a CSV or Excel file</div>
        <div class="dropzone-subtext">Takes column F (IncorrectText). Writes corrected_text ‚Üí G, explanation (JSON) ‚Üí H.</div>
        <div id="batchChosen" class="dropzone-subtext" style="display:none; font-weight:700;"></div>
      </div>
    </div>
    <input id="batchFile" name="batch_file" type="file" accept=".csv,.xlsx,.xls,text/csv,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet,application/vnd.ms-excel" style="display:none" />
    <div id="batchSelected" style="display:none; margin-top:.5rem; color: var(--text-secondary);">
      Selected: <span id="batchFileName" style="font-weight:700;"></span>
      <button type="button" id="batchFileClear" class="btn btn-secondary" style="height:28px; padding:.2rem .6rem; margin-left:.5rem;">Clear</button>
    </div>
    <input type="hidden" id="batchProvider" name="provider" value="{{ selected_provider|default:'gemini' }}">
    <div class="index-page btn-group" style="justify-content:flex-start;">
      <button id="batchSubmit" type="submit" class="btn btn-primary">Process File</button>
      <a class="btn btn-secondary" href="{% url 'batch_history' %}">Batch Jobs</a>
    </div>
  </form>
  <div id="batchProgressWrap" style="display:none; margin-top:.75rem;">
    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:.35rem;">
      <div style="font-weight:700; color: var(--text-secondary);">Processing‚Ä¶</div>
      <div id="batchPercent" style="color: var(--text-muted);">0%</div>
    </div>
    <div style="width:100%; height: 12px; background: rgba(102,126,234,.12); border-radius: 999px; overflow:hidden; border: 1px solid rgba(102,126,234,.25);">
      <div id="batchProgressBar" style="height:100%; width:0%; background: linear-gradient(135deg, var(--brand), var(--brand-2)); transition: width .3s ease;"></div>
    </div>
    <div id="batchStatusText" style="margin-top:.4rem; color: var(--text-muted); font-size:.9rem;"></div>
    <div class="index-page btn-group" style="justify-content:flex-start; align-items:center; gap:.35rem; margin-top:.5rem;">
      <a id="batchDownload" class="btn btn-secondary" href="#" style="display:none;">Download Result</a>
      <span id="batchNewBadge" class="badge-new" style="display:none;">New</span>
      <button id="batchCancelBtn" type="button" class="btn btn-danger" style="display:none;">Cancel Job</button>
      <a class="btn btn-secondary" href="{% url 'batch_history' %}">View History</a>
    </div>
  </div>
  <div class="dropzone-subtext" style="margin-top:.4rem;">Tip: First row header "IncorrectText" is kept; results go to G/H.</div>
</div>

<form id="audio-form" method="post" action="{% url 'index' %}" enctype="multipart/form-data">
  {% csrf_token %}
  <!-- Hidden provider field kept for server form validation; synced from global selection via JS -->
  <div style="display:none">{{ form.llm_provider }}</div>

  <!-- View Toggles -->
  <div class="section" style="display:flex; align-items:center; justify-content:center; gap:.5rem;">
    <div class="toggle-group" role="group" aria-label="Input toggles" style="display:flex; gap:.5rem; flex-wrap:wrap; position:relative;">
      <span id="toggleIndicator" class="toggle-indicator" aria-hidden="true"></span>
      <button type="button" id="toggleAudio" class="btn btn-secondary toggle-btn active" aria-pressed="true">üé§ Audio Input</button>
      <button type="button" id="toggleText" class="btn btn-secondary toggle-btn" aria-pressed="false">‚úèÔ∏è Text Input</button>
    </div>
  </div>

  <div class="input-carousel">
    <div class="input-track" id="inputTrack">
      <div class="slide" id="audioSlide">
  <div id="audioSection" class="section">
    <h3>üé§ Audio Input</h3>
    <div class="dropzone" id="dropzone">
      <div class="dropzone-content">
        <div class="dropzone-icon">üéµ</div>
        <div class="dropzone-text">Drag & drop audio file here</div>
        <div class="dropzone-subtext">or click to browse files</div>
      </div>
    </div>
    <input type="file" id="fileInput" name="audio_file" accept="audio/*" style="display:none;">
    <div class="btn-group">
      <button type="button" id="record" class="btn btn-secondary">üî¥ Record</button>
      <button type="button" id="stop" class="btn btn-secondary" disabled>‚èπÔ∏è Stop</button>
      <button type="button" id="upload" class="btn btn-secondary">üìÅ Upload File</button>
      <button type="button" id="clear" class="btn btn-danger" style="display:none;">üóëÔ∏è Clear</button>
    </div>
    <div class="recording-indicator" id="recordingIndicator">
      <div class="recording-dot"></div>
      <div class="recording-text">Recording... <span id="timer">00:00</span></div>
    </div>
    <div class="audio-player" id="audioPlayer">
      <audio id="audioPlayback" controls></audio>
      <div class="audio-controls"><div class="audio-info" id="audioInfo"></div></div>
    </div>
  </div>

  </div>
      <div class="slide hidden" id="textSlide">
  <div id="textSection" class="section">
    <h3>‚úèÔ∏è Text Input</h3>
    <textarea id="textInput" name="text_input" placeholder="Enter your Japanese text here for AI feedback...&#10;&#10;Example: ÁßÅ„ÅØÊò®Êó•Êò†Áîª„ÇíË¶ã„Åæ„Åó„Åü„ÄÇ"></textarea>
  </div>
      </div>
    </div>
  </div>

  <div class="submit-section">
    <button type="submit" id="submitBtn" class="btn btn-primary" disabled>
      <span id="submitText">üîç Analyze</span>
      <span id="loadingSpinner" style="display:none;">‚è≥ Analyzing...</span>
    </button>
    <div id="submitHint" class="subtitle" style="margin-top:.5rem;">Enter text or upload audio to analyze</div>
  </div>
</form>

</div>

<script>
  const recordBtn = document.getElementById('record');
  const stopBtn = document.getElementById('stop');
  const submitBtn = document.getElementById('submitBtn');
  const clearBtn = document.getElementById('clear');
  const fileInput = document.getElementById('fileInput');
  const audioPlayback = document.getElementById('audioPlayback');
  const textInput = document.getElementById('textInput');
  const dropzone = document.getElementById('dropzone');
  const audioPlayer = document.getElementById('audioPlayer');
  const audioInfo = document.getElementById('audioInfo');
  const recordingIndicator = document.getElementById('recordingIndicator');
  const timer = document.getElementById('timer');
  const audioSection = document.getElementById('audioSection');
  const textSection = document.getElementById('textSection');
  const toggleAudio = document.getElementById('toggleAudio');
  const toggleText = document.getElementById('toggleText');
  const toggleIndicator = document.getElementById('toggleIndicator');
  const inputTrack = document.getElementById('inputTrack');
  const audioSlide = document.getElementById('audioSlide');
  const textSlide = document.getElementById('textSlide');
  let currentMode = null;
  let mediaRecorder, chunks = []; let recordingStartTime; let timerInterval;

  // Drag & Drop
  dropzone.addEventListener('click', () => fileInput.click());
  dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('highlight'); });
  dropzone.addEventListener('dragleave', () => { dropzone.classList.remove('highlight'); });
  dropzone.addEventListener('drop', (e) => { e.preventDefault(); dropzone.classList.remove('highlight'); const files = e.dataTransfer.files; if (files.length > 0) { fileInput.files = files; handleFileSelect(files[0]); }});

  // Recording
  recordBtn.addEventListener('click', async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      mediaRecorder = new MediaRecorder(stream); chunks = [];
      mediaRecorder.ondataavailable = e => chunks.push(e.data);
      mediaRecorder.onstop = () => { const blob = new Blob(chunks, { type: 'audio/webm' }); const url = URL.createObjectURL(blob); audioPlayback.src = url; const file = new File([blob], 'recording.webm', { type: 'audio/webm' }); const dt = new DataTransfer(); dt.items.add(file); fileInput.files = dt.files; showAudioPlayer(file); hideRecordingIndicator(); checkSubmitButton(); requestAnimationFrame(updateCarouselHeight); };
      mediaRecorder.start(); recordBtn.disabled = true; stopBtn.disabled = false; showRecordingIndicator();
    } catch (err) { console.error('Error accessing microphone:', err); alert('Could not access microphone. Please check permissions.'); }
  });
  stopBtn.addEventListener('click', () => { if (mediaRecorder && mediaRecorder.state === 'recording') { mediaRecorder.stop(); mediaRecorder.stream.getTracks().forEach(t => t.stop()); } recordBtn.disabled = false; stopBtn.disabled = true; });

  document.getElementById('upload').addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', () => { const file = fileInput.files[0]; if (file) handleFileSelect(file); requestAnimationFrame(updateCarouselHeight); });
  clearBtn.addEventListener('click', () => { fileInput.value = ''; audioPlayer.style.display = 'none'; clearBtn.style.display = 'none'; checkSubmitButton(); requestAnimationFrame(updateCarouselHeight); });
  textInput.addEventListener('input', () => { checkSubmitButton(); requestAnimationFrame(updateCarouselHeight); });

  function handleFileSelect(file) { const url = URL.createObjectURL(file); audioPlayback.src = url; showAudioPlayer(file); checkSubmitButton(); requestAnimationFrame(updateCarouselHeight); }
  function showAudioPlayer(file) { audioPlayer.style.display = 'block'; clearBtn.style.display = 'inline-flex'; audioInfo.textContent = `${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`; }
  function showRecordingIndicator() { recordingIndicator.style.display = 'flex'; recordingStartTime = Date.now(); timerInterval = setInterval(updateTimer, 1000); }
  function hideRecordingIndicator() { recordingIndicator.style.display = 'none'; clearInterval(timerInterval); }
  function updateTimer() { const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000); const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0'); const seconds = (elapsed % 60).toString().padStart(2, '0'); timer.textContent = `${minutes}:${seconds}`; }
  function checkSubmitButton() {
    const hasAudio = fileInput.files.length > 0; const hasText = textInput.value.trim().length > 0; const isEnabled = hasAudio || hasText;
    submitBtn.disabled = !isEnabled; submitBtn.style.opacity = isEnabled ? '1' : '0.5';
    const hint = document.getElementById('submitHint'); if (hint) { hint.style.display = submitBtn.disabled ? 'block' : 'none'; hint.textContent = hasText && hasAudio ? 'Ready to analyze both text and audio' : hasText ? 'Ready to analyze text' : hasAudio ? 'Ready to analyze audio' : 'Enter text or upload audio to analyze'; }
  }

  // Section toggles
  function setToggle(btn, on) {
    btn.classList.toggle('active', on);
    btn.setAttribute('aria-pressed', on ? 'true' : 'false');
  }
  function clearAudioInputs() {
    fileInput.value = '';
    audioPlayback.removeAttribute('src');
    audioPlayer.style.display = 'none';
    clearBtn.style.display = 'none';
  }
  function selectMode(mode) {
    const audioOn = mode === 'audio';
    const textOn = mode === 'text';
    setToggle(toggleAudio, audioOn);
    setToggle(toggleText, textOn);
    // Pre-set wrapper height to target to avoid bounce
    const wrapper = document.querySelector('.input-carousel');
    if (wrapper) {
      const target = textOn ? textSection : audioSection;
      // Ensure both slides are visible for measuring and animation
      if (audioSlide && textSlide) { audioSlide.classList.remove('hidden'); textSlide.classList.remove('hidden'); }
      wrapper.style.height = target.offsetHeight + 'px';
    }
    // Slide the content carousel (after making both slides visible)
    if (inputTrack) {
      inputTrack.style.transform = audioOn ? 'translateX(0%)' : 'translateX(-50%)';
      // After transition finishes, hide the inactive slide for a single-pane view
      const offEl = audioOn ? textSlide : audioSlide;
      inputTrack.addEventListener('transitionend', () => {
        if (offEl) offEl.classList.add('hidden');
        updateCarouselHeight();
      }, { once: true });
    }
    // Move the indicator under the active toggle
    if (toggleIndicator) toggleIndicator.style.transform = textOn ? 'translateX(100%)' : 'translateX(0)';
    // Keep inputs in sync
    if (audioOn) {
      // Switching to audio: clear text
      textInput.value = '';
    } else {
      // Switching to text: clear audio
      clearAudioInputs();
    }
    checkSubmitButton();
    currentMode = mode;
    requestAnimationFrame(updateCarouselHeight);
  }

  function updateCarouselHeight(){
    const wrapper = document.querySelector('.input-carousel');
    if (!wrapper) return;
    const activeEl = (currentMode === 'text') ? textSection : audioSection;
    if (activeEl) wrapper.style.height = activeEl.offsetHeight + 'px';
  }
  toggleAudio.addEventListener('click', () => selectMode('audio'));
  toggleText.addEventListener('click', () => selectMode('text'));
  // Ensure default is audio mode and set initial height after layout
  selectMode('audio');
  window.addEventListener('load', () => requestAnimationFrame(updateCarouselHeight));
  document.addEventListener('DOMContentLoaded', () => requestAnimationFrame(updateCarouselHeight));
  // Recompute height when recording indicator toggles
  const origShow = showRecordingIndicator; const origHide = hideRecordingIndicator;
  showRecordingIndicator = function(){ origShow(); requestAnimationFrame(updateCarouselHeight); };
  hideRecordingIndicator = function(){ origHide(); requestAnimationFrame(updateCarouselHeight); };

  // Swipe support (left/right) to switch modes
  (function() {
    const swipeTargets = [document.querySelector('.toggle-group'), document.querySelector('.input-carousel')].filter(Boolean);
    let startX = 0, startY = 0, isSwiping = false;
    const THRESHOLD = 50; // pixels

    function onTouchStart(e){
      if (!e.touches || e.touches.length !== 1) return;
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      isSwiping = false;
    }
    function onTouchMove(e){
      if (!e.touches || e.touches.length !== 1) return;
      const dx = e.touches[0].clientX - startX;
      const dy = e.touches[0].clientY - startY;
      if (Math.abs(dx) > 10 && Math.abs(dx) > Math.abs(dy)) {
        // Horizontal intent detected; prevent vertical scroll from hijacking
        e.preventDefault();
        isSwiping = true;
      }
    }
    function onTouchEnd(e){
      if (!isSwiping) return;
      const touch = (e.changedTouches && e.changedTouches[0]) || null;
      if (!touch) return;
      const dx = touch.clientX - startX;
      if (Math.abs(dx) >= THRESHOLD) {
        // Swipe left -> go to text; Swipe right -> go to audio
        if (dx < 0) selectMode('text'); else selectMode('audio');
      }
      isSwiping = false;
    }
    swipeTargets.forEach(el => {
      el.addEventListener('touchstart', onTouchStart, { passive: true });
      el.addEventListener('touchmove', onTouchMove, { passive: false });
      el.addEventListener('touchend', onTouchEnd, { passive: true });
    });

    // Mouse drag support for desktop
    let mouseDown = false;
    function onMouseDown(e){ mouseDown = true; startX = e.clientX; startY = e.clientY; isSwiping = false; }
    function onMouseMove(e){ if(!mouseDown) return; const dx = e.clientX - startX; const dy = e.clientY - startY; if (Math.abs(dx) > 10 && Math.abs(dx) > Math.abs(dy)) { e.preventDefault(); isSwiping = true; } }
    function onMouseUp(e){ if(!mouseDown) return; mouseDown = false; if(!isSwiping) return; const dx = e.clientX - startX; if (Math.abs(dx) >= THRESHOLD) { if (dx < 0) selectMode('text'); else selectMode('audio'); } isSwiping = false; }
    swipeTargets.forEach(el => {
      el.addEventListener('mousedown', onMouseDown);
      el.addEventListener('mousemove', onMouseMove);
      el.addEventListener('mouseup', onMouseUp);
      el.addEventListener('mouseleave', onMouseUp);
    });
  })();

  // Loading UI on submit (do NOT disable inputs to preserve form data)
  (function() {
    const form = document.getElementById('audio-form'); if (!form) return;
    function setSubmittingUI() {
      if (form.dataset.submitting === '1') return false;
      const submitText = document.getElementById('submitText');
      const loadingSpinner = document.getElementById('loadingSpinner');
      if (submitText) submitText.style.display = 'none';
      if (loadingSpinner) loadingSpinner.style.display = 'inline';
      form.dataset.submitting = '1';
      return true;
    }
    submitBtn.addEventListener('click', () => { if (!submitBtn.disabled) setSubmittingUI(); });
    form.addEventListener('keydown', (e) => { if (e.key === 'Enter' && (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT')) { if (!submitBtn.disabled) setSubmittingUI(); }});
    form.addEventListener('submit', function() { if (form.dataset.submitting === '1') return; setSubmittingUI(); });
  })();

  // Initial check
  checkSubmitButton();

  // Shortcuts + DnD page feedback
  document.addEventListener('keydown', function(e) { if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { if (!submitBtn.disabled) { const form = document.getElementById('audio-form'); const submitText = document.getElementById('submitText'); const loadingSpinner = document.getElementById('loadingSpinner'); if (submitText) submitText.style.display = 'none'; if (loadingSpinner) loadingSpinner.style.display = 'inline'; requestAnimationFrame(() => setTimeout(() => form.submit(), 40)); } } if (e.key === 'Escape') { if (clearBtn.style.display !== 'none') { clearBtn.click(); } } });
  let dragCounter = 0; document.addEventListener('dragenter', function(e) { e.preventDefault(); dragCounter++; document.body.style.background = 'linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1))'; }); document.addEventListener('dragleave', function(e) { e.preventDefault(); dragCounter--; if (dragCounter === 0) { document.body.style.background = ''; } }); document.addEventListener('drop', function(e) { e.preventDefault(); dragCounter = 0; document.body.style.background = ''; });
</script>

<script>
  (function(){
    const form = document.getElementById('batchForm');
    if (!form) return;
    const fileInput = document.getElementById('batchFile');
    const submitBtn = document.getElementById('batchSubmit');
    const selectedWrap = document.getElementById('batchSelected');
    const fileNameEl = document.getElementById('batchFileName');
    const fileClearBtn = document.getElementById('batchFileClear');
    const dz = document.getElementById('batchDropzone');
    const chosenEl = document.getElementById('batchChosen');
    const wrap = document.getElementById('batchProgressWrap');
    const bar = document.getElementById('batchProgressBar');
    const pct = document.getElementById('batchPercent');
    const statusText = document.getElementById('batchStatusText');
    const actions = document.getElementById('batchActions');
    const dl = document.getElementById('batchDownload');
    const cancelBtn = document.getElementById('batchCancelBtn');

    let pollTimer = null;
    let currentJobId = null;

    function updateUI(percent, processed, total, status){
      if (typeof percent === 'number') {
        bar.style.width = Math.max(0, Math.min(100, percent)) + '%';
        pct.textContent = Math.max(0, Math.min(100, percent)) + '%';
      }
      if (typeof processed === 'number' && typeof total === 'number') {
        statusText.textContent = `Processed ${processed} of ${total} rows`;
      }
      if (status) {
        statusText.textContent = statusText.textContent ? statusText.textContent + ` ‚Ä¢ ${status}` : status;
      }
    }

    // Link global provider to hidden inputs
    const globalProvider = document.getElementById('globalProvider');
    const batchProvider = document.getElementById('batchProvider');
    if (globalProvider && batchProvider) {
      batchProvider.value = globalProvider.value;
      globalProvider.addEventListener('change', () => { batchProvider.value = globalProvider.value; });
    }

    async function poll(jobId){
      try {
        const res = await fetch(`/speak-ai/batch/${jobId}/status`, {
          credentials: 'same-origin',
          headers: { 'Accept': 'application/json', 'X-Requested-With': 'XMLHttpRequest' }
        });
        if (!res.ok) { throw new Error(`HTTP ${res.status}`); }
        const data = await res.json();
        if (!data.ok) throw new Error('Status error');
        updateUI(data.percent, data.processed, data.total, data.status);
        if (data.status === 'done'){
          clearInterval(pollTimer); pollTimer = null;
          dl.href = data.download_url;
          dl.style.display = 'inline-flex';
          // Draw attention to the Download button briefly
          dl.classList.add('attention');
          setTimeout(()=> dl.classList.remove('attention'), 4000);
          if (typeof newBadge !== 'undefined' && newBadge) { newBadge.style.display = 'inline-flex'; setTimeout(()=>{ newBadge.style.display='none'; }, 5000); }
          cancelBtn.style.display = 'none';
          submitBtn.disabled = false;
          submitBtn.textContent = 'Process File';
          try { localStorage.removeItem('activeBatchJobId'); } catch(e) {}
          if (window.showToast) showToast('Batch complete. Ready to download.', 'success');
        } else if (data.status === 'error'){
          clearInterval(pollTimer); pollTimer = null;
          submitBtn.disabled = false;
          submitBtn.textContent = 'Process File';
          statusText.textContent = `Failed: ${data.error || 'Unknown error'}`;
          cancelBtn.style.display = 'none';
          try { localStorage.removeItem('activeBatchJobId'); } catch(e) {}
          if (typeof newBadge !== 'undefined' && newBadge) newBadge.style.display = 'none';
          if (window.showToast) showToast(`Batch failed: ${data.error || 'Unknown'}`, 'error');
        } else if (data.status === 'canceled'){
          clearInterval(pollTimer); pollTimer = null;
          submitBtn.disabled = false;
          submitBtn.textContent = 'Process File';
          statusText.textContent = 'Canceled by user.';
          cancelBtn.style.display = 'none';
          try { localStorage.removeItem('activeBatchJobId'); } catch(e) {}
          if (typeof newBadge !== 'undefined' && newBadge) newBadge.style.display = 'none';
          if (window.showToast) showToast('Batch canceled.', 'warn');
        } else {
          // running or pending
          cancelBtn.style.display = data.cancelable ? 'inline-flex' : 'none';
        }
      } catch (e) {
        // surface a hint but continue polling
        statusText.textContent = `Waiting for status‚Ä¶ (${e})`;
      }
    }

    form.addEventListener('submit', async function(e){
      e.preventDefault();
      if (!fileInput.files || !fileInput.files[0]){
        // Custom modal like the Remove avatar dialog
        (function(){
          const modal = document.createElement('div');
          modal.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.6);z-index:10000;display:flex;align-items:center;justify-content:center;';
          modal.innerHTML = `
            <div role="dialog" aria-modal="true" style="background:var(--bg-primary);border-radius:12px;padding:1.25rem;max-width:420px;box-shadow:0 25px 50px rgba(0,0,0,0.25); border:1px solid var(--border-color);">
              <h3 style="margin:0 0 .5rem 0;color:var(--text-primary);font-size:1.05rem;">No file selected</h3>
              <p style="margin:0 0 1rem 0;color:var(--text-secondary);">Please choose a CSV or Excel file first.</p>
              <div style="display:flex;gap:.5rem;justify-content:flex-end;">
                <button class="ok-btn" style="padding:.5rem 1rem;border:1px solid var(--border-color);border-radius:8px;background:var(--bg-primary);color:var(--text-primary);cursor:pointer;">OK</button>
              </div>
            </div>`;
          document.body.appendChild(modal);
          const close = ()=>{ try{ document.body.removeChild(modal);}catch(e){} };
          modal.querySelector('.ok-btn').onclick = close;
          modal.onclick = (ev)=>{ if (ev.target === modal) close(); };
          document.addEventListener('keydown', function esc(e){ if (e.key === 'Escape'){ close(); document.removeEventListener('keydown', esc); } });
        })();
        return;
      }
      wrap.style.display = 'block';
      dl.style.display = 'none';
      cancelBtn.style.display = 'none';
      updateUI(0, 0, 0, 'Starting‚Ä¶');
      submitBtn.disabled = true;
      submitBtn.textContent = 'Queued‚Ä¶';

      const fd = new FormData(form);
      // include CSRF token
      const csrf = form.querySelector('input[name=csrfmiddlewaretoken]').value;
      try {
        const res = await fetch(form.action, {
          method: 'POST',
          body: fd,
          headers: { 'X-CSRFToken': csrf, 'Accept': 'application/json', 'X-Requested-With': 'XMLHttpRequest' },
          credentials: 'same-origin'
        });
        if (!res.ok) { throw new Error(`HTTP ${res.status}`); }
        const data = await res.json();
        if (!data.ok) throw new Error(data.error || 'Failed to start job');
        currentJobId = data.job_id;
        try { localStorage.setItem('activeBatchJobId', String(currentJobId)); } catch(e) {}
        submitBtn.textContent = 'Processing‚Ä¶';
        pollTimer = setInterval(() => poll(currentJobId), 1200);
        if (window.showToast) showToast(`Started batch job #${currentJobId}`, 'info');
      } catch (err){
        submitBtn.disabled = false;
        submitBtn.textContent = 'Process File';
        statusText.textContent = `Failed to start: ${err}`;
      }
    });

    if (cancelBtn){
      cancelBtn.addEventListener('click', async function(){
        if (!currentJobId) return;
        cancelBtn.disabled = true;
        try {
          await fetch(`/speak-ai/batch/${currentJobId}/cancel`, {
            method: 'POST',
            headers: { 'X-CSRFToken': form.querySelector('input[name=csrfmiddlewaretoken]').value, 'Accept': 'application/json', 'X-Requested-With': 'XMLHttpRequest' },
            credentials: 'same-origin'
          });
          statusText.textContent = 'Cancel requested‚Ä¶';
          if (window.showToast) showToast('Cancel requested‚Ä¶', 'warn');
        } catch(e) {}
      });
    }

    // Resume if a job is already running (e.g., user navigated away and back)
    (function resumeIfNeeded(){
      try {
        const url = new URL(window.location.href);
        const urlJob = url.searchParams.get('job_id');
        if (urlJob){
          localStorage.setItem('activeBatchJobId', urlJob);
          // Clean the URL
          url.searchParams.delete('job_id');
          try { window.history.replaceState({}, document.title, url.toString()); } catch(e) {}
        }
        const saved = localStorage.getItem('activeBatchJobId');
        if (saved){
          currentJobId = parseInt(saved, 10);
          if (!isNaN(currentJobId)){
            wrap.style.display = 'block';
            dl.style.display = 'none';
            cancelBtn.style.display = 'inline-flex';
            submitBtn.disabled = true;
            submitBtn.textContent = 'Processing‚Ä¶';
            pollTimer = setInterval(() => poll(currentJobId), 1200);
            if (window.showToast) showToast(`Resumed batch job #${currentJobId}`, 'info');
          }
        }
      } catch(e) {}
    })();

    // Show selected file name, allow clearing
    function humanSize(bytes){
      if (!bytes && bytes !== 0) return '';
      const units = ['B','KB','MB','GB'];
      let i = 0; let n = bytes;
      while (n >= 1024 && i < units.length-1){ n /= 1024; i++; }
      return `${n.toFixed(n >= 10 || i === 0 ? 0 : 1)} ${units[i]}`;
    }
    function updateSelected(fOverride){
      let f = null;
      // If called with an event, safely read target files
      if (fOverride && fOverride.target && fOverride.target.files) {
        f = fOverride.target.files[0] || null;
      } else if (fOverride && (typeof fOverride === 'object') && 'name' in fOverride) {
        // Called with a File object
        f = fOverride;
      } else {
        f = (fileInput.files && fileInput.files[0]) || null;
      }
      if (f){
        fileNameEl.textContent = `${f.name} (${humanSize(f.size)})`;
        selectedWrap.style.display = 'block';
        if (chosenEl){ chosenEl.textContent = `Selected: ${f.name} (${humanSize(f.size)})`; chosenEl.style.display = 'block'; }
        if (dz) dz.classList.add('has-file');
      } else {
        selectedWrap.style.display = 'none';
        if (chosenEl){ chosenEl.style.display = 'none'; }
        if (dz) dz.classList.remove('has-file');
      }
    }
    // Wrap to avoid passing the Event object directly to updateSelected
    fileInput.addEventListener('change', function(){ updateSelected(); });
    if (fileClearBtn){
      fileClearBtn.addEventListener('click', function(){
        fileInput.value = '';
        updateSelected();
      });
    }
    if (dz){
      dz.addEventListener('keydown', function(e){ if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); fileInput.click(); }});
      dz.addEventListener('dragover', function(e){ e.preventDefault(); dz.classList.add('highlight'); });
      dz.addEventListener('dragleave', function(){ dz.classList.remove('highlight'); });
      dz.addEventListener('drop', function(e){
        e.preventDefault(); dz.classList.remove('highlight');
        const files = e.dataTransfer && e.dataTransfer.files;
        if (files && files.length){
          // Some browsers disallow programmatic assignment to file inputs; still show selection
          try { fileInput.files = files; } catch(err) {}
          updateSelected(files[0]);
        }
      });
    }
  })();
</script>
{% endblock %}
